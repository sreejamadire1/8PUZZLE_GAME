#include <stdio.h>
#include<bits/stdc++.h>
using namespace std;

struct Node{
    Node* parent;
    vector<vector<int>>mat;
    int x,y;
    int cost;
    int level;
};
struct comp{
    bool operator()(const Node* lhs,const Node* rhs)const
    {
               return (lhs->cost + lhs->level) > (rhs->cost + rhs->level); 
    }
    
};
Node* newNode(vector<vector<int>>mat,int x,int y,int newx,int newy,int level,Node* parent){
    Node* node= new Node;
    node->parent=parent;
    node->mat=mat;
    swap(node->mat[x][y],node->mat[newx][newy]);
    node->cost=INT_MAX;
    node->level=level;
    node->x=newx;
    node->y=newy;
    return node;
}
int calculateCost(vector<vector<int>>ini,vector<vector<int>>f,int i_s){
    int c=0;
    for(int i=0;i<i_s;i++){
        for(int j=0;j<i_s;j++){
            if(ini[i][j] && ini[i][j]!=f[i][j])
            c++;
        }
    }
    return c;
}
void printMatrix(vector<vector<int>>mat,int i_s){
    for(int i=0;i<i_s;i++){
        for(int j=0;j<i_s;j++)
            cout<<mat[i][j]<<" ";
            cout<<endl;
        
    }
}
void printPath(Node* root,int i_s){
    if(root==NULL)return;
    printPath(root->parent,i_s);
    printMatrix(root->mat,i_s);
    cout<<endl;
}
int row[] = { 1, 0, -1, 0 }; 
int col[] = { 0, -1, 0, 1 }; 
int isSafe(int x,int y,int n){
    return (x>=0 && x<n && y>=0 && y<n);
}
void solve(vector<vector<int>>i,int x,int y,vector<vector<int>>f,int i_s){
    int min_cost=INT_MAX;
    set<vector<vector<int>>>s;
    priority_queue<Node*,vector<Node*>,comp>pq;
    Node* root=newNode(i,x,y,x,y,0,NULL);
    root->cost=calculateCost(i,f,i_s);
    min_cost=root->cost;
    s.insert(root->mat);
    pq.push(root);
    while(!pq.empty()){
        Node* min=pq.top();
        ///condition for the case in which goal state cannot be reached 
        if(min->cost > min_cost){
            cout<<"cannot reach goal state from initial state"<<endl;
            return ;
        }
        if(min->cost < min_cost)
        min_cost=min->cost;
        pq.pop();
        if(min->cost == 0){
            printPath(min,i_s);
            return;
        }
        for(int i=0;i<4;i++){
            if(isSafe(min->x+row[i],min->y+col[i],i_s)){
               /* swap(min->mat[min->x][min->y],min->mat[min->x+row[i]][min->y+col[i]]);
                 if(s.find(min->mat)==s.end()){
                swap(min->mat[min->x][min->y],min->mat[min->x+row[i]][min->y+col[i]]);
               */ 
               Node* child=newNode(min->mat,min->x,min->y,min->x+row[i],min->y+col[i],min->level+1,min);
                child->cost=calculateCost(child->mat,f,i_s);
                pq.push(child);
/*               s.insert(child->mat);
                }
                else{
                    //if the child node to be generated is already present in tree then no need to generate 
                 swap(min->mat[min->x][min->y],min->mat[min->x+row[i]][min->y+col[i]]);
                 
                 
                }
*/          }
        }
    }
}

int main()
{
        clock_t start, end; 
    start = clock(); 

    vector<vector<int>>i{
       {0,1,3},
       {4,2,5},
       {7,8,6}
   };
   vector<vector<int>>f{
       {1,2,3},
       {4,5,6},
       {7,8,0}

   };
   int x,y,i_s=i.size();
   for(int s=0;s<i_s;s++){
       for(int j=0;j<i_s;j++){
           if(i[s][j]==0)
           {
               x=s;
               y=j;
               break;
           }
       }
   }
   solve(i,x,y,f,i_s);
       end = clock(); 
    double time_taken = double(end - start) / double(CLOCKS_PER_SEC); 
    cout << "Time taken by program is : " << fixed  
         << time_taken << setprecision(5); 
    cout << " sec " << endl; 

}
0.000327sec(//if the child node to be generated is already present in tree then no need to generate)
0.000171sec(if no need to check )